{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":""},{"location":"#what-is-this","title":"What is this?","text":"<p>This is the Main Code Guideline that Aethel Bon Crown uses whenever coding in C++.</p> <p>It is designed to be used for solo C++ Projects and solo C++ Libraries, different guidelines will be created for different scales of Team Projects and also for different languages. (At the time of writing)  </p>"},{"location":"#general-format","title":"General Format","text":"<p>At the time of writing, it is under my admission that I do not have a real understanding on how to go about organising documentation, much less something as verbose as a Code guideline.</p> <p>It should be stated that major changes and overhauls are likely to be done for this project within the near future. This should be kept in mind not only for readers of this but also to myself, within the future, no matter how annoying it may seem.</p>"},{"location":"#due-to-the-aforementioned-reasons-the-current-format-for-the-guideline-will-be","title":"Due to the aforementioned reasons the current format for the guideline will be :","text":"<ul> <li>A topic per page</li> <li>Topics are organised within Scopes</li> <li>Each Page discussing an aspect of C++ Syntax and the rules that should be followed</li> </ul>"},{"location":"#what-is-a-topic","title":"What is a Topic?","text":"<p>A Topic within this Guideline can be defined as a C++ Statement or series of statements which have been written with a singular intention.</p> <p>These intentions generally already posses a term associated with them such as Instantiation or Assignment however others don't.  An Example of this being : <code>using an if statement to end a function early.</code></p>"},{"location":"#why-organise-topics-within-scopes","title":"Why Organise topics within Scopes?","text":"<p>Several Topics should change rules depending on context. Using an if statement within a function where you have access to the return statement should have a different ruleset than within Local Scope, or naming conventions of public and private data members should be distinguishable from variables declared within the scope of a function.</p> <p>I believe that a good code guideline should be formatted in a way that at the very least naming convention wise, you should be able to look at a snippet of code and tell where it is located.</p> <p>With this in mind we can segment groups of rules into the environment you find them in or in C++ what we can call Scopes (the actual C++ language feature).</p>"},{"location":"#interlude","title":"Interlude","text":"<p>With all this in mind, I hope whoever finds this is able to read this to completion.  </p> <p>As of writing the Guideline is incomplete. Even when it reaches a level where it's more to put together, I will most likely keep adding small experts here and there.</p> <p>Happy Reading !</p>"},{"location":"Complex-Type-Scope/","title":"Complex Type Scope","text":"<p>The Following Category discusses various Complex Types and everything written in it. Topics within this category will discuss all things related to complex types.</p>"},{"location":"Complex-Type-Scope/Complex-Type-Layout/","title":"Complex Type Layout","text":""},{"location":"Complex-Type-Scope/Complex-Type-Layout/#classes","title":"Classes","text":"<p><code>C++ Classes</code> should follow the following layout : <pre><code>class GenericInterface \n{\nprivate:\n    int _common{};\n    float _deltaCommon{};\n\n    void _Init();\nprotected:\n/*NOTHING IS IN THIS AND IS ONLY FOR THE EXAMPLE*/\npublic:\n    //Constructor\n    GenericInterface();\n    //Destructor\n    ~GenericInterface();\n    //Change the values within the Interface\n    void Modify();\n}\n</code></pre></p> <p>The <code>Private Access specifier</code> should be the 1st declared within a Class.  </p> <p>While there is a lot of debate on whether the <code>private</code> or <code>public</code> specifier should come first, it is my belief that if users of my libraries or code are investigating the internals it is from an inquisitive standpoint to see how things are working internally rather than to check all the methods they can interact within the interface as documentation should suffice in said cases.  </p> <p>In addition, for a Class where the internals should be assumed unread by the users, I prefer to facilitate the lives of the programmer/s who worked on the project.  Seeing the internal <code>attributes</code> first allows readers to get into the headspace of who wrote it when it was written, which is important for those modifying the project after a long absence and those wishing to learn from it. Due to all these reasons, the <code>private</code> access specifier should be the 1st one within the <code>Class</code> layout.</p> <p><code>protected</code> should be just after because generally they function as the <code>private</code> specifier within a base class.  </p> <p><code>Class attributes</code> should be first within the <code>private class scope</code>, <code>private class methods</code> coming after. Same layout for anything within <code>protected</code>.  Within the <code>public class scope</code>, <code>constructors</code>, <code>destructors</code>and <code>operator overloads</code>, should be written first, followed by methods unique to that class, then lastly getters and setters.  </p> <p>Within a <code>class</code>, every <code>access specifier</code> used should be explicitly declared.</p>"},{"location":"Complex-Type-Scope/Complex-Type-Layout/#structs","title":"Structs","text":"<p><code>C++ structs</code> should follow the following layout :</p> <pre><code>struct genBundle \n{\n    float FloatArray[3];\n    int IntArray[3];\n    size_t AddressArray[3];\n}\n</code></pre> <p>Due to the fact that generally <code>structs</code> will only possess <code>attributes</code> and no <code>methods</code> the layout is simple, a list of the <code>attributes.</code> For specific cases where there are <code>methods</code>, they should be under the <code>attributes.</code></p>"},{"location":"Complex-Type-Scope/Naming-Conventions-Attributes-and-Methods/","title":"Naming Conventions : Attributes and Methods","text":""},{"location":"Complex-Type-Scope/Naming-Conventions-Attributes-and-Methods/#private","title":"Private","text":"<p>To differentiate between different <code>Access specifier scopes</code>, and code within a function, <code>Attributes within the Private class Scope</code>, should be <code>_camelCase</code>, <code>methods</code> should be <code>_PascalCase</code>. Example : <pre><code>class GenericInterface \n{\nprivate:\n\n    int _common{};\n    float _deltaCommon{};\n\n    void _Init();\n}; \n</code></pre></p>"},{"location":"Complex-Type-Scope/Naming-Conventions-Attributes-and-Methods/#protected","title":"Protected","text":"<p>If there is a <code>protected specifier</code>, then <code>attributes under the protected class scope</code> should be <code>_camelCase</code> and the <code>private attributes</code> should be <code>__camelCase</code>, methods should be <code>_pascalCase</code> and <code>private methods</code> should be <code>__PascalCase</code>. Example : <pre><code>class GenericInterface \n{\nprivate:\n    size_t __id{};\n\n    void __Init();\nprotected:\n\n    int _common{};\n    float _deltaCommon{};\n\n    virtual void _CustomInit();\n};\n</code></pre></p>"},{"location":"Complex-Type-Scope/Naming-Conventions-Attributes-and-Methods/#public","title":"Public","text":"<p>Within the <code>Public class scope</code>, <code>attributes</code> should be <code>PascalCase</code> and <code>methods</code> should be the same. Example : <pre><code>struct genBundle \n{\n    float FloatArray[3];\n    int IntArray[3];\n    size_t AddressArray[3];\n\n    void Sort();\n}\n</code></pre></p>"},{"location":"Complex-Type-Scope/Naming-Conventions-Complex-Type-Names/","title":"Naming Conventions : Complex Type Names","text":""},{"location":"Complex-Type-Scope/Naming-Conventions-Complex-Type-Names/#classes","title":"Classes","text":"<p><code>C++ Classes</code> should be named using <code>PascalCase</code>, this is to differentiate them from <code>structs and user defined aliases</code> : <pre><code>class GenericInterface \n{\n\n}; \n</code></pre></p> <p>In addition, due to the fact that the Instantiation of Classes shouldn't happen too often, the upmost clarity can be pursued with the names of Classes being several whole words such as : <code>MemoryMatrix</code>.  However, if very well known shorthands can be used instead, then they should be.</p>"},{"location":"Complex-Type-Scope/Naming-Conventions-Complex-Type-Names/#structs","title":"Structs","text":"<p><code>C++ Structs</code> should be named using <code>camelCase</code> : <pre><code>struct shapeBundle \n{\n\n}; \n</code></pre></p> <p><code>structs</code> within C++ are functionally the same as <code>Classes</code>, however in practice will be used as bundles of data while <code>Classes</code> will be used as interfaces.  Since <code>structs</code> will be treated close to primitive types, their naming convention should mirror/be close to it hence <code>camelCase</code>.  </p> <p>Since <code>structs</code> on average are instantiated more often than <code>Classes</code> and due to the fact they're simpler in function than a <code>Class</code>, their names should be one word or several shorthands. Except for exceptional cases where alternatives cannot be found, <code>structs</code> should be 2 short words maximum in length.</p> <p><code>unions</code> should also be <code>camelCase</code> since they possess a similar role as <code>structs</code> within a program in most use cases. They should also use the same rules in terms of length as <code>structs</code>.</p>"},{"location":"Complex-Type-Scope/Naming-Conventions-Template-Parameters/","title":"Naming Conventions : Template Parameters","text":"<p>Within C++, <code>templates</code> should generally only be restricted to <code>Classes</code> and their respective <code>methods</code>.  <code>Template Parameters</code> should be written in <code>SCREAMING_SNAKE_CASE</code>. The main reason for this is that I believe that they should be easy to differentiate from variables initialized within function scope.   </p> <p><code>typename</code> should be preferred over <code>class</code> for <code>template parameters</code>, for the simple reason that I find it more relevant a term. If the <code>template parameter</code> is for a general type than it should be called <code>T</code>, for anything else it should be named after its purpose. For any subsequent types they should be named <code>TT</code>, <code>TTT</code> etc. Example : <pre><code>template &lt;typename T, size_t SIZE&gt;\nclass Array\n{\n    //Code Here\n}\n</code></pre></p>"},{"location":"Function-Scope/","title":"Function Scope","text":""},{"location":"Function-Scope/Function-Parameters-Layout/","title":"Function Parameters Layout","text":""},{"location":"Function-Scope/Lambda-Layout/","title":"Lambda Expression Layout","text":""},{"location":"Function-Scope/Naming-Conventions-Function-Parameters/","title":"Naming Conventions : Function Parameters","text":""},{"location":"Function-Scope/Naming-Conventions-Functions/","title":"Naming Conventions : Functions","text":""},{"location":"Global-Scope/","title":"Global Scope","text":"<p>The Following Category discusses The Global Scope and everything written in it. This generally covers file setup and compiler directives topics.</p>"},{"location":"Global-Scope/File-And-Folder-Naming/","title":"File And Folder Naming","text":""},{"location":"Global-Scope/Global-Variables/","title":"Global Variables","text":"<p>Global Constant variables should be written in <code>SCREAMING_SNAKE_CASE</code>. They should always be within a namespace. They should clearly describe what they are, so they should be as long as they need to be. Example : </p> <pre><code>namespace MAT\n{\n    constexpr float PI{ 3.14159 };\n}\n</code></pre>"},{"location":"Global-Scope/Header-Guard/","title":"Header Guard","text":"<p>The Header Guard is a directive used to ensure that header files are only copied once into any single file. While <code>#pragma once</code> can be used, <code>#ifndef</code> will be preferred for a multitude of reasons :  </p> <p>First off, and while it is a small reason it must be stated, some compilers do not support <code>#pragma once</code>.  In Addition, <code>#ifndef</code> allows for a more \"hands on control\" of what is included. For example, including a mock header who uses the same <code>#ifndef</code> as another more complex class. Personally, I find it increases readability and makes headers easier to navigate as the guard describes the file name generally. Finally, <code>#ifndef</code> is still the standard while <code>#prgama once</code> isn't.</p> <p>As for naming convention, the defined variable should be in <code>SCREAMING_SNAKE_CASE</code>, in the format <code>LIBRARY/PROJECTNAME_FILENAME_H</code>. Example : <pre><code>#ifndef ARSON_TENSOR2DARRAY_H\n#define ARSON_TENSOR2DARRAY_H\n\n//file here\n\n#endif\n</code></pre></p>"},{"location":"Global-Scope/Include-Directives-Layout/","title":"Include Directives Layout","text":"<p><code>include directives</code> should be organised first by standard library headers, then by external library headers, then by headers found within the project then finally by the class definition headers if it applies. Absolute <code>include directives</code> should be opted over relative ones (prefer <code>&lt;&gt;</code> over <code>\" \"</code>). Example :</p> <pre><code>//STD Library\n#include &lt;iostream&gt;\n#incldude &lt;cmath&gt;\n//EXTERNAL LIBRARY + PROJECT HEADERS\n#include &lt;Arson/Tensor2DArray.h&gt;\n#include &lt;GeneralInterface.h&gt;\n//CLASS DEFINITION\n#include &lt;shapeBundle.h&gt;\n</code></pre>"},{"location":"Global-Scope/Naming-Conventions-Namespaces/","title":"Naming Conventions : Namespaces","text":"<p>If creating a C++ library, a <code>namespace</code> should encapsulate each element. As for how to go about naming them, for the outer <code>namespace</code> they should be the name of the library shortened, into a 3-5 character sequence. Example : <pre><code>//Library Arson\nnamespace Arn\n{\n\n}\n</code></pre></p> <p>If a library is big enough to warrant having several <code>namespaces</code> than the <code>namespace</code> should be the subject also shortened into a 3-5 characters sequence. Example : <pre><code>//Coalescence Engine\nnamespace COSCE\n{\n    namespace GFX\n    {\n    }\n}\n</code></pre></p>"},{"location":"Global-Scope/Naming-Conventions-Type-Aliases/","title":"Naming Conventions : Type Aliases","text":""},{"location":"Local-Scope-Within-Main/","title":"Local Scope Within Main","text":"<p>The Following Category discusses The Local Scope Within Main and everything written in it. The Majority of topics within this category will cover rules which apply to all code in other categories.</p>"},{"location":"Local-Scope-Within-Main/Initialization/","title":"Initialization","text":""},{"location":"Local-Scope-Within-Main/Initialization/#initialization-type","title":"Initialization Type","text":"<p>There are several ways to go about <code>initialization</code> within C++. <pre><code>int main()\n{\n    //Copy Initialization\n    int a = 5;\n    //Direct Initialization\n    int b(5);\n    //Direct List Initialization\n    int c{5};\n}\n</code></pre></p> <p><code>Direct List Initialization</code> is preferred between all of the above methods. There are several reasons for this. The Primary reason is for consistency. <code>Class</code> and <code>Aggregate initialization</code> all use <code>{}</code>, having <code>initialization</code> specifically always be associated with it is useful for legibility. In addition <code>Direct List Initialization</code> allows for <code>Zero-Initialization</code>.  This reduces bugs as variables <code>initialised</code> with no values may keep garbage data.</p>"},{"location":"Local-Scope-Within-Main/Initialization/#multiple-initializations","title":"Multiple Initializations","text":"<p>Within C++ it is possible for you to <code>initialise</code> several variables of the same type within a singular statement. Example : <pre><code>int main()\n{\n    int x{}, y{};\n}\n</code></pre> For legibility\u2019s sake this practice will be strictly banned within this coding guideline. While I find it reasonable to use this syntax for variables such as <code>x,y,z</code> like the above example, it gets quickly out of hand the moment you use variables whose names exceed a singular character in length.  Due to the aforementioned reason and for the sake of consistency, each <code>initialised</code> variable should occupy a new line.</p>"},{"location":"Local-Scope-Within-Main/Naming-Conventions-Variables/","title":"Naming Conventions : Variables","text":"<p>Variables should be written in <code>camelCase</code>. In terms of length, they should be 1\u20132 words generally so they don't occupy too much space. They should be short, simple descriptions of what data is stored within. While this is said, I generally think that <code>ptr</code>suffixes/prefixes to Variables are unneeded as even though they are by definition descriptive, the variable in question tends to be used the same as any other variable. However, if any pointer variable when being used heavily deals with pointer arithmetic or any such pointer specific operations, than its name should reflect that. Example :  <pre><code>int main()\n{\n    int addressStep{3};\n    int* unparsedData{new int{10}};\n\n    for (size_t i{0}; i &lt; sizeof(int); ++i)\n    {\n        //code here\n    }\n}\n</code></pre></p>"},{"location":"Local-Scope-Within-Main/Pointer-and-Reference-Notation/","title":"Pointer and Reference Notation","text":"<p>There's a small bit of contention about how to go about syntax for <code>pointer</code> and <code>reference</code> type variable initialization. The 2 main ways of Initialization are the following : <pre><code>int main()\n{\n    int* ptr{};\n    int *ptr{};\n}\n</code></pre></p> <p>The Notation that the Starve Style Guideline will be adopting is the former : <code>int* ptr{};</code>. The reasons for this is simply that I consider that pointer and reference type variables as their own type, distinct from their original variants.  </p> <p><code>pointer</code> variables hold an (ARCHITECTURE DEPENDANT) 8 byte long string of numbers. If the pointer points to an integer as an example, their sizes, data and usage will vary. <code>reference</code> variables are aliases for already existing variables and as such occupy no space on the RAM. In terms of the various factors they match that of their counterparts, however for consistency reasons they should be put on the left.</p>"},{"location":"Local-Scope-Within-Main/Scope/","title":"Scope","text":"<p>Scope in C++ is marked by <code>{}</code>, the categories of this code guideline encapsulate the scopes which are relevant within the majority of Projects and Libraries. To properly delimitate different scopes within a given project, All Curly Brackets delimitating Scopes should occupy a new line by itself. Example : <pre><code>void foo()\n{   \n    if (check)\n    {\n        std::cout &lt;&lt; \"Check One\";\n        std::cout &lt;&lt; \"Finshed Checks!\";\n    }\n\n    if (check) \n    { \n        std::cout &lt;&lt; \"Code Ran\"; \n    }\n}\n</code></pre></p>"},{"location":"Scope-in-Flow-Control-Statements/","title":"Scope in Flow Control Statements","text":""},{"location":"Scope-in-Flow-Control-Statements/Multi-Condition-If-Statements/","title":"Multi-Condition If Statements","text":""},{"location":"Scope-in-Flow-Control-Statements/Naming-Conventions-Loop-Index/","title":"Naming Conventions : Loop Index","text":""},{"location":"Scope-in-Flow-Control-Statements/Naming-Conventions-Loop-Index/#general-cases","title":"General Cases","text":"<p>Within a <code>for loop</code>, the variable used as an index should follow the following naming convention within general cases : </p> <pre><code>for (size_t i{0}; i &lt; size; ++i)\n{\n    for (size_t j{0};j &lt; size; ++j)\n    {\n        for (size_t k{0}; k &lt; size; ++k)\n        {\n            ++arr[i][j][k];\n        }\n    }\n}\n</code></pre> <p><code>i,j,k</code> is used as it is generally the most universally understood variable names for index's for <code>for loops</code> across software engineering.  Using <code>index, deltaIndex,..</code> was entertained however has been dropped due to the overall lack of clarity it possessed compared to the unofficial standard. </p>"},{"location":"Scope-in-Flow-Control-Statements/Naming-Conventions-Loop-Index/#other-cases","title":"Other Cases","text":"<p>Within cases where a more apt name can be chosen for the index, they should be preferred over <code>i,j,k</code>.  An Example being <code>x,y,z</code> when the loop is iterating over something that can be called spatial dimensions.  </p> <p>It is to be stated that generally there will be moments where words can be a more apt variable name for an index within a loop as they're more immediately understood, such as <code>position</code>.  Within such cases attempts should be done to shorten them into globally understood shorthands, such as for the above example <code>pos</code>. If a nice shorthand cannot be chosen for the situation at hand and <code>i,j,k</code> will lead to more confusion than clarity, than the index variable name can be chosen as a whole word.</p> <p>It must be said that while this section is based around <code>for loops</code>, other loop based <code>flow control statements</code> such as <code>while loops</code> and <code>do while loops</code> should apply the same rules for variables which serve the same or similar purposes of being indexes. </p>"}]}